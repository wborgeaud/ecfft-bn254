use std::convert::TryInto;

use crate::{ecfft::EcFftParameters, utils::isogeny::Isogeny};
use ark_ff::BigInteger256;

pub type F = ark_bn254::Fr;
/// Number of 64-bit limbs needed to represent field elements.
const NUM_LIMBS: usize = 4;

/// ECFFT parameters for the BN254 base field `F`.
/// Computed with the curve `E = EllipticCurve(F, [a, b])` with
/// `a, b = 1, 5612291247948481584627780310922020304781354847659642188369727566000581075360`.
pub struct Bn254ScalarEcFftParameters;

impl EcFftParameters<F> for Bn254ScalarEcFftParameters {
    /// The curve `E` has order `21888242871839275222246405745257275088712935808829559400805562964428910444544`
    /// with factorization `2^14 * 3^2 * 229 * 503 * 205460939795467 * 55374745393148401254803 * 113267149255983544517087125127`.
    const LOG_N: usize = 11;

    const N: usize = 1 << Self::LOG_N;

    /// Get the coset from the `bn254_coset` file. This file can be generated by running `get_params.sage`.
    fn coset() -> Vec<F> {
        std::fs::read_to_string("bn254_scalar_coset")
            .expect("Run `get_params.sage` to generate the coset.")
            .split_whitespace()
            .map(|s| s.parse().unwrap())
            .collect::<Vec<u64>>()
            .chunks(NUM_LIMBS)
            .map(|chunk| BigInteger256::new(chunk.try_into().unwrap()).into())
            .collect()
    }

    /// Get the isogenies from the `bn254_isogenies` file. This file can be generated by running `get_params.sage`.
    fn isogenies() -> Vec<Isogeny<F>> {
        std::fs::read_to_string("bn254_scalar_isogenies")
            .expect("Run `get_params.sage` to generate the coset.")
            .split_whitespace()
            .map(|s| s.parse().unwrap())
            .collect::<Vec<u64>>()
            .chunks(5 * NUM_LIMBS)
            .map(|chunk| {
                let numerator = (0..3)
                    .map(|i| {
                        BigInteger256::new(
                            chunk[i * NUM_LIMBS..(i + 1) * NUM_LIMBS]
                                .try_into()
                                .unwrap(),
                        )
                        .into()
                    })
                    .collect::<Vec<_>>()
                    .try_into()
                    .unwrap();
                let denominator = (3..5)
                    .map(|i| {
                        BigInteger256::new(
                            chunk[i * NUM_LIMBS..(i + 1) * NUM_LIMBS]
                                .try_into()
                                .unwrap(),
                        )
                        .into()
                    })
                    .collect::<Vec<_>>()
                    .try_into()
                    .unwrap();
                Isogeny {
                    numerator,
                    denominator,
                }
            })
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use crate::ecfft::{EcFftCosetPrecomputation, EcFftParameters, EcFftPrecomputationStep};

    use crate::bn254_scalar::{Bn254ScalarEcFftParameters, F};
    use ark_ff::{Field, One, PrimeField, Zero};
    use ark_poly::univariate::DenseOrSparsePolynomial;
    use ark_poly::DenseUVPolynomial;
    use ark_poly::{univariate::DensePolynomial, Polynomial};
    use ark_std::{
        rand::{distributions::Standard, prelude::Distribution, Rng},
        test_rng,
    };

    #[test]
    /// Tests that precomputations don't panic.
    fn test_precompute() {
        Bn254ScalarEcFftParameters::precompute_on_coset(&Bn254ScalarEcFftParameters::coset());
        Bn254ScalarEcFftParameters::precompute_on_coset(
            &Bn254ScalarEcFftParameters::coset()
                .into_iter()
                .step_by(2)
                .collect::<Vec<_>>(),
        );
    }

    /// Tests the extend function with a polynomial of degree `2^i - 1`.
    fn test_extend_i<F: PrimeField, P: EcFftParameters<F>>(
        i: usize,
        precomputation: &EcFftCosetPrecomputation<F, P>,
    ) where
        Standard: Distribution<F>,
    {
        let n = 1 << i;
        let mut rng = test_rng();
        let coeffs: Vec<F> = (0..n).map(|_| rng.gen()).collect();
        let poly = DensePolynomial { coeffs };
        let EcFftPrecomputationStep { s, s_prime, .. } =
            &precomputation.steps[Bn254ScalarEcFftParameters::LOG_N - 1 - i];
        let evals_s = s.iter().map(|x| poly.evaluate(x)).collect::<Vec<_>>();
        let evals_s_prime = s_prime.iter().map(|x| poly.evaluate(x)).collect::<Vec<_>>();
        assert_eq!(evals_s_prime, precomputation.extend_s_to_s_prime(&evals_s));
        assert_eq!(evals_s, precomputation.extend_s_prime_to_s(&evals_s_prime));
    }

    #[test]
    /// Tests the extend function for various degrees.
    fn test_extend() {
        let precomputation =
            Bn254ScalarEcFftParameters::precompute_on_coset(&Bn254ScalarEcFftParameters::coset());
        for i in 1..Bn254ScalarEcFftParameters::LOG_N {
            test_extend_i::<F, _>(i, &precomputation);
        }
    }

    #[test]
    /// Tests constructing vanishing polynomial on first moeity of coset.
    fn test_vanish() {
        let precomputation = Bn254ScalarEcFftParameters::precompute();
        for coset_precomp in precomputation.coset_precomputations.iter() {
            let s = coset_precomp
                .coset
                .iter()
                .step_by(2)
                .copied()
                .collect::<Vec<F>>();
            let s_prime = coset_precomp
                .coset
                .iter()
                .skip(1)
                .step_by(2)
                .copied()
                .collect::<Vec<F>>();

            let vanish_poly = s
                .into_iter()
                .map(|s| DensePolynomial::from_coefficients_slice(&[-s, F::one()]))
                .fold(
                    DensePolynomial::from_coefficients_slice(&[F::one()]),
                    |acc, poly| &acc * &poly,
                );

            let vanish_on_s_prime_calc = s_prime
                .iter()
                .map(|val| vanish_poly.evaluate(val))
                .collect::<Vec<F>>();
            assert_eq!(coset_precomp.vanish_on_s_prime, vanish_on_s_prime_calc);
        }
    }

    #[test]
    /// Tests constructing vanishing polynomial on first moeity of coset.
    fn test_vanish_squared_rem_xnn() {
        let precomputation = Bn254ScalarEcFftParameters::precompute();
        for coset_precomp in precomputation.coset_precomputations.iter().rev() {
            let s = coset_precomp
                .coset
                .iter()
                .step_by(2)
                .copied()
                .collect::<Vec<F>>();

            let vanish_poly = s
                .into_iter()
                .map(|s| DensePolynomial::from_coefficients_slice(&[-s, F::one()]))
                .fold(
                    DensePolynomial::from_coefficients_slice(&[F::one()]),
                    |acc, poly| &acc * &poly,
                );

            let vanish_squared = &vanish_poly * &vanish_poly;

            let n = coset_precomp.coset.len();

            let log_n = n.trailing_zeros() as usize;
            let mut x_to_nn = DensePolynomial::from_coefficients_slice(&[F::zero(), F::one()]);
            for _ in 0..log_n - 1 {
                x_to_nn = &x_to_nn * &x_to_nn;
            }

            let x_nn = DenseOrSparsePolynomial::from(&x_to_nn);
            let vanish_squared_dors = DenseOrSparsePolynomial::from(&vanish_squared);
            let (_, vanish_squared_rem_xnn) =
                vanish_squared_dors.divide_with_q_and_r(&x_nn).unwrap();

            let vanish_on_s_prime_calc = coset_precomp
                .coset
                .iter()
                .map(|val| vanish_squared_rem_xnn.evaluate(val))
                .collect::<Vec<F>>();
            assert_eq!(coset_precomp.z0z0_rem_xnn, vanish_on_s_prime_calc);
        }
    }

    #[test]
    /// Tests the `evaluate_over_domain` function for various degrees.
    fn test_eval() {
        type P = Bn254ScalarEcFftParameters;
        let precomputation = P::precompute();
        for i in 0..P::LOG_N {
            let mut rng = test_rng();
            let coeffs: Vec<F> = (0..P::N >> i).map(|_| rng.gen()).collect();
            let poly = DensePolynomial { coeffs };
            let now = std::time::Instant::now();
            let evals = P::sub_coset(i)
                .iter()
                .map(|x| poly.evaluate(x))
                .collect::<Vec<_>>();
            dbg!(now.elapsed().as_secs_f32());
            assert_eq!(evals, precomputation.evaluate_over_domain(&poly));
            dbg!(now.elapsed().as_secs_f32());
        }
    }

    #[test]
    /// Tests the `redc` function for various degrees.
    fn test_redc() {
        type P = Bn254ScalarEcFftParameters;
        let precomputation = P::precompute();
        for i in 1..P::LOG_N {
            let coset = &precomputation.coset_precomputations[P::LOG_N - i].coset;
            let n = coset.len();
            let log_n = n.trailing_zeros() as usize;
            let s = coset.iter().step_by(2).copied().collect::<Vec<F>>();
            let mut x_to_nn = DensePolynomial::from_coefficients_slice(&[F::zero(), F::one()]);
            for _ in 0..log_n - 1 {
                x_to_nn = &x_to_nn * &x_to_nn;
            }
            let vanish_on_s = s
                .iter()
                .map(|s| DensePolynomial::from_coefficients_slice(&[-*s, F::one()]))
                .fold(
                    DensePolynomial::from_coefficients_slice(&[F::one()]),
                    |acc, poly| &acc * &poly,
                );
            let mut rng = test_rng();
            let poly = DensePolynomial::<F>::rand(n - 1, &mut rng);
            let evals = precomputation.evaluate_over_domain(&poly);
            let redc_evals = precomputation.redc(&evals);
            let x_nn = DenseOrSparsePolynomial::from(&x_to_nn);
            let (_, vanish_on_s_inverse) =
                extended_gcd_algorithm(DenseOrSparsePolynomial::from(&vanish_on_s), x_nn);
            let prod = &vanish_on_s * &vanish_on_s_inverse;
            let vanish_on_s_inverse = &vanish_on_s_inverse * prod[0].inverse().unwrap();
            let x_nn = DenseOrSparsePolynomial::from(&x_to_nn);
            let vanish_on_s_inverse = DenseOrSparsePolynomial::from(&vanish_on_s_inverse);
            let vanish_on_s_inverse = vanish_on_s_inverse.divide_with_q_and_r(&x_nn).unwrap().1;
            let redc_poly_no_mod = &poly * &vanish_on_s_inverse;
            let redc_wrapped = DenseOrSparsePolynomial::from(&redc_poly_no_mod);
            let redc_poly = redc_wrapped.divide_with_q_and_r(&x_nn).unwrap().1;
            let mut redc_evals_from_poly = Vec::new();
            for val in coset.iter() {
                redc_evals_from_poly.push(redc_poly.evaluate(val));
            }
            assert_eq!(redc_evals, redc_evals_from_poly);
        }
    }

    #[test]
    fn test_modulo() {
        type P = Bn254ScalarEcFftParameters;
        let precomputation = P::precompute();
        for i in 1..P::LOG_N {
            let coset = &precomputation.coset_precomputations[P::LOG_N - i].coset;
            let n = coset.len();
            let log_n = n.trailing_zeros() as usize;
            let mut x_to_nn = DensePolynomial::from_coefficients_slice(&[F::zero(), F::one()]);
            for _ in 0..log_n - 1 {
                x_to_nn = &x_to_nn * &x_to_nn;
            }

            let mut rng = test_rng();
            let poly = DensePolynomial::<F>::rand(n - 1, &mut rng);
            let evals = precomputation.evaluate_over_domain(&poly);
            let mod_evals = precomputation.modulo(&evals);
            let poly_dors = DenseOrSparsePolynomial::from(&poly);
            let x_nn = DenseOrSparsePolynomial::from(&x_to_nn);
            let remainder = poly_dors.divide_with_q_and_r(&x_nn).unwrap().1;
            let mut remainder_evals = Vec::new();
            for val in coset.iter() {
                remainder_evals.push(remainder.evaluate(val));
            }
            assert_eq!(mod_evals, remainder_evals);
        }
    }

    #[test]
    /// Tests the `evaluate_over_domain` function for various degrees.
    fn test_interpolate() {
        type P = Bn254ScalarEcFftParameters;
        let precomputation = P::precompute();
        for i in (0..P::LOG_N).rev() {
            let mut rng = test_rng();
            let coeffs: Vec<F> = (0..P::N >> i).map(|_| rng.gen()).collect();
            let poly = DensePolynomial {
                coeffs: coeffs.clone(),
            };

            let evals = P::sub_coset(i)
                .iter()
                .map(|x| poly.evaluate(x))
                .collect::<Vec<_>>();
            let now = std::time::Instant::now();
            let poly_ecfft = precomputation.interpolate(&evals);
            dbg!(now.elapsed().as_secs_f32());
            assert_eq!(poly_ecfft, poly);
            dbg!(now.elapsed().as_secs_f32());

            let poly_ecfft = precomputation.interpolate(&coeffs);
            let evals = precomputation.evaluate_over_domain(&poly_ecfft);
            assert_eq!(evals, coeffs);
        }
    }

    /// Returns the extended GCD of `a` and `b`. That is polynomials `s` and `t` such that
    /// `a * t + b * s = gcd(a, b)`.
    fn extended_gcd_algorithm<F: PrimeField>(
        a: DenseOrSparsePolynomial<F>,
        b: DenseOrSparsePolynomial<F>,
    ) -> (DensePolynomial<F>, DensePolynomial<F>) {
        let mut s = DensePolynomial::from_coefficients_vec(vec![F::one()]);
        let mut old_s = DensePolynomial::from_coefficients_vec(vec![F::zero()]);
        let mut t = DensePolynomial::from_coefficients_vec(vec![F::zero()]);
        let mut old_t = DensePolynomial::from_coefficients_vec(vec![F::one()]);
        let mut r = b;
        let mut old_r = a;
        while !r.is_zero() {
            let (quotient, new_r) = old_r.divide_with_q_and_r(&r).unwrap();
            old_r = r;
            r = DenseOrSparsePolynomial::from(new_r);
            let new_s = &old_s - &(&quotient * &s);
            old_s = s;
            s = new_s;
            let new_t = &old_t - &(&quotient * &t);
            old_t = t;
            t = new_t;
        }
        (old_s, old_t)
    }
}
